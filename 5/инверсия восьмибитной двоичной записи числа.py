# (№ 1749) Автомат обрабатывает натуральное 
# число N < 256 по следующему алгоритму:
# 1) Строится восьмибитная двоичная запись числа N.
# 2) Инвертируются все разряды исходного числа, кроме последней 
# единицы и стоящих за ней нулей (0 заменяется на 1, 1 на 0).
# 3) Полученное число переводится в десятичную систему счисления.
# Для какого значения N результат работы алгоритма равен 193?

# Давайте разберем как это решать.
# По мне это самая тяжелая вариация 5-ого задания.

# Давайте напишем функцию для перевода числа
# в десятичную с.с. из двоисной с.с.
# Все прям как на буажке. Мы начинаем с конца,
# возводя 2 в порядкойвый номер числа (начиная с нуля)
# и умножая это на самое число.
# То есть это пункт 3 в условии.
def perevod(s):
	result = 0 # Переменная для хранения ответа (числа в 10 с.с.).
	x = 0 # Переменная для контроля порядкогого номера.

	# Итерируем через число в двоичной с.с. (с конца, я s перевернул [::-1]).
	for i in s[::-1]:
		result += (2 ** x) * int(i)
		x += 1 # Каждую итерация +1 порядкой номер.

	# Вернем результат (число в 10 с.с.).
	return result

# Напишем функцию для предания ей восьмибитного двоичного вида
# и инвертирования его битов до посленей 1 и 0 после нее.
# То есть это пункты 1 и 2 в условии.
def make(s):
	s = str(bin(s)[2:]) # Перевдем число в двоичную с.с. и уберем 0b в начале юзая [2:].
	result = "" # Переменная для хранения результата.
	count = 0 # Переменная для счета единиц.
	count_one = s.count("1") # Количество единиц в s.
	
	# Так, вот это очень важно!
	# Если не написать вот это вот условие, то функция выполнится,
	# но неправильно. Как например у меня на последнем пробнике ГЫЫЫ.
	# В условии сказано 8-битная. То есть должно быть восемь ноликов и единиц.
	# И это условие проверяет, если в в строке меньше 8 символов,
	# то добавляем незначашие нули в начало пока в строке не будет 8 символов.
	# При этом! Не может такого быть что у нас будет 9 символов в строке,
	# так как в условии есть ограничение до 265.
	if len(s) <= 8:
		s = "0" * (8 - len(s)) + s # Я решил тут сделать коротко. Просто вычесть из 8 текущее количество.

	# Теперь у нас есть строка где восел двоичных чисел.
	# Нам нужно как-то ее инвертировать. И при этом так,
	# чтобы инвертировать все кроме последней 1 и 0 после него.
	# Я придумал делать так. Каждый раз когда мы находим 1,
	# вы делаем count += 1. И когда-то случится что count
	# будет равер count_one (общему количеству едениц).
	# И когда такое случится, мы будем понимать что перед нами
	# последняя единица. И мы ее не инвертируем и просто записывает ее
	# и числа после нее как есть. Поэтому в двух условиях - перед нами 1,
	# перед нами 0. Мы внутри них проверяем, не дошли ли мы до последней единицы.
	# Если мы дошли, то просто добавляем i (неинвертированный).
	# А вот если мы пока еще не дошли, то инветируем текущее число.

	# Итерируем через нашу восьмибитную двичную строку.
	for i in s:
		# Если текущий элемент это 1, то
		if i == "1":
			count += 1 # Прибавляем 1 в счетчик единиц.

			# Если эта единица последняя, то
			if count >= count_one:
				result += i # Добавляем неивертированное число.
			# Если мы еще не дошли до последней единицы, то
			else:
				result += "0" # Добавляем ивертированное число.
		else:
			# Если эта единица последняя, то
			if count >= count_one:
				result += i # Добавляем неивертированное число.
			# Если мы еще не дошли до последней единицы, то
			else:
				result += "1" # Добавляем неивертированное число.

	# Возвращаем result.
	return result

# Итериурем от 1 до 256.
# И пропускаем i сначала через make(),
# потом через perevos().
for i in range(1, 257):
	n = perevod(make(i))

	# Если i, прошедшее через две функции,
	# в результате равно 193, то
	if n == 193:
		print(i) # Выводим это i.

# Ответ - 63.

