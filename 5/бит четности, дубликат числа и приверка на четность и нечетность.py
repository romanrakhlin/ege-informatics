# (№ 1774) На вход алгоритма подаётся натуральное число N. 
# Алгоритм строит по нему новое число R следующим образом.
# 1. Строится двоичная запись числа N.
# 2. К этой записи дописывается (дублируется) последняя цифра.
# 3. Затем справа дописывается бит чётности: 0, 
# если в двоичном коде полученного числа чётное число единиц, 
# и 1, если нечётное.
# 4. К полученному результату дописывается ещё один бит чётности.
# Полученная таким образом запись 
# (в ней на три разряда больше, чем в записи исходного числа N) 
# является двоичной записью искомого числа R. 
# Укажите минимальное число N, 
# после обработки которого автомат получает число, большее 97.

# Создадим функцию для перевода из 2с.с. в 10с.с.
# Я уже до этого делал подобное, так что думаю что вы
# уже с ней знакомы. Она работает по тому же принципу,
# что и перевод на бумажке.
def perevod(s):
	result = 0
	x = 0

	for i in s[::-1]:
		result += (2 ** x) * int(i)
		x += 1

	return result

# Эта функция обрабатывает число.
# Внизу я расставлю цифры, вы по ним ориентируйтесь.
# Алгоритм:
# 1 - Переводим число в 2с.с. 
# (убираем первые 2 символа 0b c помощью [2:]).
# 2 - Дублируем последнее число.
# 3 - Проваеряем четность или нечетность числа
# и добавляем в конец бит четности.
# (Что такое Бит Четности - https://ru.wikipedia.org/wiki/Бит_чётности)
# 4 - То же самое что и третее.
# 5 - Переводим число из 2с.с. в 10с.с.
# с помощью функции: которую мы написали выше.
def prepare(n):
	### 1 ###
	s = bin(n)[2:]

	### 2 ###
	s += s[len(s) - 1]

	### 3 ###
	if s.count("1") % 2 == 0:
		s += "0"
	else:
		s += "1"

	### 4 ###
	if s.count("1") % 2 == 0:
		s += "0"
	else:
		s += "1"

	### 5 ###
	result = perevod(s)
	return result

# Перебираем все числа от 1 до 1000
# и если функция prepare(число) возвращает
# новоо число большее 97, то мы выводим i,
# при котором нам это удалось и останавливает цикл.
for i in range(1, 1000):
	n = prepare(i)
	if n > 97:
		print(i)
		break

