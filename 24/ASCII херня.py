# Текстовый файл 24-2.txt содержит последовательность из строчных и заглавных букв английского алфавита и цифр,
# всего не более 106 символов. Убывающей подпоследовательностью будем называть последовательность символов,
# расположенных в порядке уменьшения их номера в кодовой таблице символов ASCII.
# Определите длину наибольшей убывающей подпоследовательности.

# Перед решением этой херни, вы должны знать что такое ASCII.
# Ну и желательно что такое Unicode.
# https://en.wikipedia.org/wiki/ASCII

# В питоне, с ASCII работают так:
# метод ord() дает номер символа в таблице ASCII.
# метож char() принимает номер символа и дает символ по этому номеру.

# Сначала мы считаем инфу с файла и запишем ее в переменную data.
with open("24-2.txt", "r") as f:
    data = f.readline()

# Создадим arr c хранения всех символов из data.
# Но ток номера этих символов из таблицы ASCII.
# В том же порядке, что они и идут в data.
arr = []

# Перебираем все символы в data,
# получаем номер символа и закиываем номер в массив arr.
for i in data:
    arr.append(ord(i))

# Я решил не ебаться с самописными алгоритмами,
# написанными на коленке на пару сек.
# Мы будем сортировать как показывает Поляков
# в своих конспектах. И как это делаем большинство блогеров на ютубе.

# Задаем изначальню длину. Она разва 1, потому что
# в символе изначально итак длина 1.
count = 1

# Так же зададим переменную для счета максимальной длины.
# В цикле дальше мы будем сравнивать найденную длину с максимальной,
# и если она будет больше максимальной, мы задаем новую максимальную длину.
countMax = 1

# Перебирем числа от 1, до длины массива.
# Ни в коем случае нельзя начинать с 0!
# Потому что мы хотим сравнивать символ с предыдущим.
for i in range(1, len(arr)):
    # Если элемент мельше предыдущего, то
    if arr[i] < arr[i - 1]:
        count += 1 # Увеличиваем счетчик.
        # Если текущий счетчик больше максимальной длины, то
        if count > countMax:
            kMax = k # То это новая максимальная длина.
    # Если убывающая цепочка окончилась, то
    else:
        count = 1 # Задаем текущему счетчику снова 1.

# Выводим максимальную длину.
print(countMax)

# Ответ: 8