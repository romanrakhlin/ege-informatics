# Задача номер 39 из сборника К. Полякова
# Код взят и частично изменен: https://www.youtube.com/watch?v=WO_2P87SLSs&t=908s


# Тк это рекурсия, то прога свова и свона перебирает уже
# до этого найденные значения. Изза чего работает довольно медленно.
# Чтобы это пофиксить, мы будем сохранять уже найденные значения в словарь.
results = {}

def game(S):
	# Проверяем, искали ли мы уже ранне эти S.
	# Если искали, то просто возвращаем результат работы программы для них.
	if S in results:
		return results[S]

	# Если значение больше или равно победному 25,
	# то возвращаем 0, тк это уже победа
	if S >= win:
		# Сохраним в словарь результат работы проги.
		results[S] = 0

		# Вернем 0
		return 0
	# Если меньше 25, то
	else:
		# Зададим переменную, в которую будем сохранять следующий шаг.
		# Например, из числа 13 мы можем получить либо 15, либо 26.
		# Именно 15 и 26 нам и нужно сохранить в этот массив.
		next_move = [game(S + 2), game(S * 2)]

		# Если количество камней, после одного из ходов
		# ведет на 0 (те на позицию, в которой мы уже победители),
		# то с этого места можно победить за один ход.
		if 0 in next_move:
			# Сохраним в словарь результат работы проги.
			results[S] = 1

			# Вернем 1
			return 1
		# Мы будем числа в массиве на то что они положительные,
		# то есть ведут только на победные ходы. В таком случае,
		# игрок который с них ходит обречен на поражение.
		# Нам главное понять, за сколько ходом он проиграет.
		# И если например в массиве лежит 1 и 2. Понятное дело,
		# что игрок не захочет проигрывать сразу после своего хода,
		# понятное дело, он будет тянуть время. Поэтому он
		# захочет проигать на второй ход соперника. Поэтому выберем максимальное
		# из двух и умножим его на -1.
		elif min(next_move) > 0:
			# Сохраним в словарь результат работы проги.
			results[S] = max(next_move) * -1

			# Зареторним
			return max(next_move) * -1
		# Теперь поробуем построить выигрышную стратегию.
		# То есть в массиве например есть 1 и -1.
		# Так как текущий игрок хочет выиграть, он выберет ход на -1,
		# потому что так его соперник проиграет за 1 ход.
		# Или, еще один пример, в массиве есит -2 и -1.
		# Игроку нужно, чтобы он выиграл как можно скорее.
		# Поэтому тут его выбор падет на -1.
		else:
			# Создадим временный массив. В который будем складывать
			# отрицательные числа.
			arr = []

			# Перебираем все числа из массива next_move.
			for i in next_move:
				# Если число отрицательное, то
				if i < 0:
					# Добавляем его во временный массив.
					arr.append(i)

			# Сохраним в словарь результат работы проги.
			results[S] = (-1 * max(arr)) + 1

			# Возвращаем наибольшее из отрицательных чисел
			# и делаем его положительным, после чего, добавляем 1
			return (-1 * max(arr)) + 1

# Задодим число, при котором наступает победа.
win = 25

# Перебираем числа с конца (тк так быстрее).
for S in range(win, 0, -1):
	n = game(S)

	# Выводим получившуюся таблицу.
	print(S, n)
	
# Для решения просто анализируем получившуюся таблицу.
# Если не понятно что такое эти 1 и -1, -2, то почитайте
# у Полякова, в фацле с разбором задач 19, 20, 21.

