# Задача № 2426 из сборника К. Полякова
# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит куча камней. 
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может увеличить количество 
# камней в куче в три раза, добавить в кучу один камень, или 3 камня, при этом после 
# каждого хода в куче должно быть нечетное количество камней. Например, пусть в куче было 8 камней. 
# Тогда за один ход можно получить кучу из 9 камней или из 11 камней 
# (увеличить количество камней в три раза нельзя, т.к. после этого хода получится четное количество камней – 24). 
# Для того чтобы делать ходы, у каждого игрока есть неограниченное количество камней. Игра завершается в тот момент, 
# когда количество камней в куче становится не менее 51. 
# В начальный момент в куче было S камней; 1 ≤ S ≤ 50. 
# Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника. 

# Ответьте на следующие вопросы:
# 19. Известно, что Ваня выиграл своим первым ходом после неудачного первого хода Пети. 
# Назовите минимальное значение S, при котором это возможно.
# 20. Найдите два наибольших значения S, при которых у Пети есть выигрышная стратегия, 
# причём Петя не может выиграть первым ходом, но может выиграть своим вторым ходом независимо от того, 
# как будет ходить Ваня. Найденные значения запишите в ответе в порядке возрастания. 
# 21. Сколько существует значений S, при которых у Вани есть выигрышная стратегия, 
# позволяющая ему выиграть вторым ходом при любой игре Пети.

# Тк это рекурсия, то прога свова и свона перебирает уже
# до этого найденные значения. Изза чего работает довольно медленно.
# Чтобы это пофиксить, мы будем сохранять уже найденные значения в словарь.
results = {}

def game(S):
	# Проверяем, искали ли мы уже ранне эти S.
	# Если искали, то просто возвращаем результат работы программы для них.
	if S in results:
		return results[S]

	# Если значение больше или равно победному 25,
	# то возвращаем 0, тк это уже победа
	if S >= win:
		# Сохраним в словарь результат работы проги.
		results[S] = 0

		# Вернем 0
		return 0
	# Если меньше win, то
	else:
		# Зададим переменную, в которую будем сохранять следующий шаг.
		# Например, из числа 13 мы можем получить либо 15, либо 26.
		# Именно 15 и 26 нам и нужно сохранить в этот массив.

		# Но так как нам нужны те S, которые при ходе будет нечетными.
		# Создадим массив со всеми возможными исходами.
		a = [S * 3, S + 1, S + 3]

		# Зададим массив, в который будем сохранять уже отобранные ходы.
		next_move = []

		# Итерируем черем массив a.
		for i in a:
			# Если этот ход превратит S в нечетное число, то
			if i % 2 != 0:
				# Добавляем подходящий ход в next_move.
				next_move.append(game(i))

		# Если количество камней, после одного из ходов
		# ведет на 0 (те на позицию, в которой мы уже победители),
		# то с этого места можно победить за один ход.
		if 0 in next_move:
			# Сохраним в словарь результат работы проги.
			results[S] = 1

			# Вернем 1
			return 1
		# Мы будем числа в массиве на то что они положительные,
		# то есть ведут только на победные ходы. В таком случае,
		# игрок который с них ходит обречен на поражение.
		# Нам главное понять, за сколько ходом он проиграет.
		# И если например в массиве лежит 1 и 2. Понятное дело,
		# что игрок не захочет проигрывать сразу после своего хода,
		# понятное дело, он будет тянуть время. Поэтому он
		# захочет проигать на второй ход соперника. Поэтому выберем максимальное
		# из двух и умножим его на -1.
		elif min(next_move) > 0:
			results[S] = max(next_move) * -1
			return max(next_move) * -1
		# Теперь поробуем построить выигрышную стратегию.
		# То есть в массиве например есть 1 и -1.
		# Так как текущий игрок хочет выиграть, он выберет ход на -1,
		# потому что так его соперник проиграет за 1 ход.
		# Или, еще один пример, в массиве есит -2 и -1.
		# Игроку нужно, чтобы он выиграл как можно скорее.
		# Поэтому тут его выбор падет на -1.
		else:
			# Создадим временный массив. В который будем складывать
			# отрицательные числа.
			arr = []

			# Перебираем все числа из массива next_move.
			for i in next_move:
				# Если число отрицательное, то
				if i < 0:
					# Добавляем его во временный массив.
					arr.append(i)

			# Сохраним в словарь результат работы проги.
			results[S] = (max(arr) * -1) + 1

			# Возвращаем наибольшее из отрицательных чисел
			# и делаем его положительным, после чего, добавляем 1
			return (max(arr) * -1) + 1

# Задодим число, при котором наступает победа.
win = 51

# Перебираем числа с конца (тк так быстрее).
for S in range(win, 0, -1):
	n = game(S)

	# Выводим получившуюся таблицу.
	print(S, n)

# Чтобы получить ответы, анализируем получившуюся таблицу.

# 19. В этом задании нас просят найти минимальное число,
# при котором Ваня победит своим первым ходом.
# Это случится только если Петя будет ходить с хода -1.
# В таблице видим, что минимальное S, которое дает -1 это 7.
# Ответ: 7

# 20. Если упроситить условте, нас просят найти S,
# при котором Петя, ходя первым, выиграет за 2 хода.
# В таблице ищем два наибольших S, которые дают 2.
# Это числа 12 и 14.
# Ответ: 12 14

# 21. Тут нас просят найти сколько есть S, при которых Ваня
# выиграет за 2 хода. Нам нужно найти сколько S, дают -2.
# -2 дают S 1 и 2. Всего их 2.
# Ответ: 2

