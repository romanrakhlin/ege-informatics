# # Задача № 3487 из сборника К. Полякова
# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежит две кучи камней. 
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить 
# в любую кучу один камень или увеличить количество камней в первой куче в два раза 
# или увеличить количество камней во второй куче в три раза. Игра завершается в тот момент, 
# когда общее количество камней в двух кучах становится не менее 30. 
# В начальный момент в первой куче было K камней, а во второй – S камней, K+S ≤ 29.

# Ответьте на следующие вопросы:
# 19. Сколько существует пар (K; S), таких что Ваня выигрывает первым ходом при любой игре Пети?
# 20. При S=7, найдите минимальное и максимальное значение K, 
# при котором у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
# − Петя не может выиграть за один ход;
# − Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Найденные значения запишите в ответе в порядке возрастания.
# 21. При K=1 найдите такое значение S, при котором, при котором одновременно выполняются два условия:
# – у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# – у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.

# Тк это рекурсия, то прога свова и свона перебирает уже
# до этого найденные значения. Изза чего работает довольно медленно.
# Чтобы это пофиксить, мы будем сохранять уже найденные значения в словарь.
results = {}

# Функция будет принимать на вход количество камней в первой куче (x)
# И количество камней во второй куче (S)
def game(x, S):
	# Проверяем, искали ли мы уже ранне эти x и S.
	# Если искали, то просто возвращаем результат работы программы для них.
	if (x, S) in results:
		return results[(x, S)]
	# Если в сумме в двух кучах камей достаточно для победы,
	# то возвращаем 0 (уже победная позиция).
	if x + S >= win:
		# Сохраним в словарь результат работы проги.
		results[(x, S)] = 0

		# Вернем 0
		return 0
	# Если же в двух кучах в сумме не хватает камней то победы, то
	else:
		# Так же зададим массив, в котором будут храниться
		# все 4 возможных исхода.
		next_move = [game(x + 1, S), game(x, S + 1), game(x * 2, S), game(x, S * 3)]
		
		# Если текущая позиция ведет хоть на один 0, то
		# она выигрышная за 1 ход. Возвращаем 1.
		if 0 in next_move:
			# Сохраним в словарь результат работы проги.
			results[(x, S)] = 1

			# Вернем 1
			return 1
		# Если из текущей позиции можно походить только на
		# положительную, то это значит, что она проигрышная,
		# тк ведет соперника на победу.
		# Но тк мы хотим оттягивать поражение как можно дольше,
		# то мы походим на проигрыш за самое долгое количество ходов.
		# Поэтому выберем максимальное и умножим на -1.
		elif min(next_move) > 0:
			# Сохраним в словарь результат работы проги.
			results[(x, S)] = max(next_move) * -1

			# Ретурним это же.
			return max(next_move) * -1
		# Если же в массиве есть хоть одно отрицательное число,
		# то значит, что эта позиция выигрышная.
		# И тут мы уже хотим выиграть как можно быстрее,
		# поэтому выберем выигрыш за самое маленькое количество шагов.
		# Так как мы рассматриваем отрицательные числа, мы берем наибольше ез них,
		# далее делаем его положительным и прибавляем 1.
		else:
			# Создадим временный массив. В который будем складывать
			# отрицательные числа.
			arr = []

			# Перебираем все числа из массива next_move.
			for i in next_move:
				# Если число отрицательное, то
				if i < 0:
					# Добавляем его во временный массив.
					arr.append(i)

			# Сохраним в словарь результат работы проги.
			results[(x, S)] = (-1 * max(arr)) + 1

			# Возвращаем наибольшее из отрицательных чисел
			# и делаем его положительным, после чего, добавляем 1
			return (-1 * max(arr)) + 1

# Задодим число, при котором наступает победа.
win = 30

# Давайте реализуем решения к трем задачам.
# Будем пользоваться кучей, которую написали выше.

# 19. Тк нам нужно найти количество пар, при которых
# Ваня выигрывает своим первым ходом. Это -1.
# Найдем количество таких пар.

# Зададим переменную count, котрая будет их считать.
count = 0

# Перебираем все варианты S
for S in range(win, 0, -1):
	# Перебираем все варианты K
	for K in range(win, 0, -1):
		n = game(K, S)

		# Если текущая пара, запущенная в функцию,
		# выдает -1, увеличиваем счетчик на 1.
		if n == -1:
			count += 1

# Выводим количество таких пар.
print("19 Задание:")
print(count)
print()
# Ответ: 7

# 20. Тут нам уже надо S, но нам нужно найти K.
# А именно минимальное и максимальное значение K,
# при которых значение game(K, S) будет равно 2.
# То есть где Петя выигрывает за 2 хода.

# Зададим массив, в которй будем складывать
# Все подходящие значения. Массивы позваляют
# легко находить min() и max().
arr = []

# Перебираем все варианты K
for K in range(win, 0, -1):
	n = game(K, 7)

	# Если текущая пара, запущенная в функцию,
	# выдает 2, то кладем K массив.
	if n == 2:
		arr.append(K)

# Выводим минимальное и максимальное значение K.
print("20 Задание:")
print(min(arr), max(arr))
print()
# Ответ: 7

# 21. В этом задании нам нужно найти такие
# пары K и S, что в результате работы game()
# будет выведено -2. То есть победа Пети за 2 хода.

# Перебираем все варианты S
for S in range(win, 0, -1):
	n = game(1, S)

	# Если текущая пара, запущенная в функцию,
	# выдает -2, печатем его.
	if n == -2:
		print("20 Задание:")
		print(S)

# Ответ: 8

# Для решения просто анализируем получившуюся таблицу.
# Если не понятно что такое эти 1 и -1, -2, то почитайте
# у Полякова, в фацле с разбором задач 19, 20, 21.